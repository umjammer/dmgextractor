/*-
 * Copyright (C) 2014 Erik Larsson
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.catacombae.dmg.encrypted;

import java.io.PrintStream;
import org.catacombae.dmgextractor.Util;

/** This class was generated by CStructToJavaClass. */
public class ExperimentalV1Header {
    /*
     * struct ExperimentalV1Header
     * size: 1276 bytes
     * description: 
     *
     * BP    Size   Type          Identifier              Description                                                                 
     * -------------------------------------------------------------------------------------------------------------------------------
     * 0     1*16   uint8_t[16]   unknown0                Unknown data.                                                               
     * 16    4      uint32_t      blockSize               Block size of the encrypted block data.                                     
     * 20    4      uint32_t      unknownInt20            Unknown integer.                                                            
     * 24    4      uint32_t      unknownInt24            Unknown integer.                                                            
     * 28    4      uint32_t      unknownInt28            Unknown integer.                                                            
     * 32    4      uint32_t      unknownInt32            Unknown integer.                                                            
     * 36    4      uint32_t      unknownInt36            Unknown integer.                                                            
     * 40    4      uint32_t      unknownInt40            Unknown integer.                                                            
     * 44    4      uint32_t      unknownInt44            Unknown integer.                                                            
     * 48    4      uint32_t      kdfIterationCount       Iteration count for the key derivation function (normally 1000).            
     * 52    4      uint32_t      kdfSaltLen              Length of kdfSalt in bytes.                                                 
     * 56    1*32   uint8_t[32]   kdfSalt                 Salt value for the key derivation function                                  
     * 88    4      uint32_t      laban                   Unknown variable with observed value 16/0x10.                               
     * 92    4      uint32_t      edward                  Unknown variable with observed value 5/0x5.                                 
     * 96    4      uint32_t      palle                   Unknown variable with observed value 0x80000001.                            
     * 100   4      uint32_t      lisa                    Unknown variable with observed value 128/0x80.                              
     * 104   1*32   uint8_t[32]   unwrapIv                Initialization Vector for encryption-key unwrapping.                        
     * 136   4      uint32_t      lenWrappedAesKey        Length of wrappedAesKey in bytes (max 256).                                 
     * 140   1*256  uint8_t[256]  wrappedAesKey           The AES key (wrapped).                                                      
     * 396   4      uint32_t      unknownInt396           Unknown integer (observed value: 91/0x5B).                                  
     * 400   4      uint32_t      unknownInt400           Unknown integer (observed value: 160/0xA0).                                 
     * 404   1*32   uint8_t[32]   unknown404              Unknown data (observed: 8 bytes filled, rest 0).                            
     * 436   4      uint32_t      lenWrappedHmacSha1Key   Length of wrappedHmacSha1Key in bytes (max 256).                            
     * 440   1*256  uint8_t[256]  wrappedHmacSha1Key      The HMAC SHA-1 key (wrapped).                                               
     * 696   4      uint32_t      unknownInt696           Unknown integer (observed value: 91/0x5B).                                  
     * 700   4      uint32_t      unknownInt700           Unknown integer (observed value: 160/0xA0).                                 
     * 704   1*32   uint8_t[32]   unknown704              Unknown data (obs. 8 bytes filled, rest 0).                                 
     * 736   4      uint32_t      lenWrappedIntegrityKey  Length of wrappedIntegrityKey.                                              
     * 740   1*256  uint8_t[256]  wrappedIntegrityKey     Integrity key.                                                              
     * 996   4      uint32_t      lenUnknown1000          Length of unknown1000.                                                      
     * 1000  1*256  uint8_t[256]  unknown1000             Unknown key-like field with length specified by unknownRnd95GaLen (max 256).
     * 1256  8      uint64_t      decryptedDataLength     Length in bytes of the underlying data stream.                              
     * 1264  4      uint32_t      possibleHeaderVersion   Could be a variable indicating header version (observed: 1/0x1).            
     * 1268  1*8    uint8_t[8]    signature               Header signature (ASCII: 'cdsaencr').                                       
     */
    
    public static final int STRUCTSIZE = 1276;
    
    private final byte[] unknown0 = new byte[1*16];
    private final byte[] blockSize = new byte[4];
    private final byte[] unknownInt20 = new byte[4];
    private final byte[] unknownInt24 = new byte[4];
    private final byte[] unknownInt28 = new byte[4];
    private final byte[] unknownInt32 = new byte[4];
    private final byte[] unknownInt36 = new byte[4];
    private final byte[] unknownInt40 = new byte[4];
    private final byte[] unknownInt44 = new byte[4];
    private final byte[] kdfIterationCount = new byte[4];
    private final byte[] kdfSaltLen = new byte[4];
    private final byte[] kdfSalt = new byte[1*32];
    private final byte[] laban = new byte[4];
    private final byte[] edward = new byte[4];
    private final byte[] palle = new byte[4];
    private final byte[] lisa = new byte[4];
    private final byte[] unwrapIv = new byte[1*32];
    private final byte[] lenWrappedAesKey = new byte[4];
    private final byte[] wrappedAesKey = new byte[1*256];
    private final byte[] unknownInt396 = new byte[4];
    private final byte[] unknownInt400 = new byte[4];
    private final byte[] unknown404 = new byte[1*32];
    private final byte[] lenWrappedHmacSha1Key = new byte[4];
    private final byte[] wrappedHmacSha1Key = new byte[1*256];
    private final byte[] unknownInt696 = new byte[4];
    private final byte[] unknownInt700 = new byte[4];
    private final byte[] unknown704 = new byte[1*32];
    private final byte[] lenWrappedIntegrityKey = new byte[4];
    private final byte[] wrappedIntegrityKey = new byte[1*256];
    private final byte[] lenUnknown1000 = new byte[4];
    private final byte[] unknown1000 = new byte[1*256];
    private final byte[] decryptedDataLength = new byte[8];
    private final byte[] possibleHeaderVersion = new byte[4];
    private final byte[] signature = new byte[1*8];
    
    public ExperimentalV1Header(byte[] data, int offset) {
	System.arraycopy(data, offset+0, unknown0, 0, 1*16);
	System.arraycopy(data, offset+16, blockSize, 0, 4);
	System.arraycopy(data, offset+20, unknownInt20, 0, 4);
	System.arraycopy(data, offset+24, unknownInt24, 0, 4);
	System.arraycopy(data, offset+28, unknownInt28, 0, 4);
	System.arraycopy(data, offset+32, unknownInt32, 0, 4);
	System.arraycopy(data, offset+36, unknownInt36, 0, 4);
	System.arraycopy(data, offset+40, unknownInt40, 0, 4);
	System.arraycopy(data, offset+44, unknownInt44, 0, 4);
	System.arraycopy(data, offset+48, kdfIterationCount, 0, 4);
	System.arraycopy(data, offset+52, kdfSaltLen, 0, 4);
	System.arraycopy(data, offset+56, kdfSalt, 0, 1*32);
	System.arraycopy(data, offset+88, laban, 0, 4);
	System.arraycopy(data, offset+92, edward, 0, 4);
	System.arraycopy(data, offset+96, palle, 0, 4);
	System.arraycopy(data, offset+100, lisa, 0, 4);
	System.arraycopy(data, offset+104, unwrapIv, 0, 1*32);
	System.arraycopy(data, offset+136, lenWrappedAesKey, 0, 4);
	System.arraycopy(data, offset+140, wrappedAesKey, 0, 1*256);
	System.arraycopy(data, offset+396, unknownInt396, 0, 4);
	System.arraycopy(data, offset+400, unknownInt400, 0, 4);
	System.arraycopy(data, offset+404, unknown404, 0, 1*32);
	System.arraycopy(data, offset+436, lenWrappedHmacSha1Key, 0, 4);
	System.arraycopy(data, offset+440, wrappedHmacSha1Key, 0, 1*256);
	System.arraycopy(data, offset+696, unknownInt696, 0, 4);
	System.arraycopy(data, offset+700, unknownInt700, 0, 4);
	System.arraycopy(data, offset+704, unknown704, 0, 1*32);
	System.arraycopy(data, offset+736, lenWrappedIntegrityKey, 0, 4);
	System.arraycopy(data, offset+740, wrappedIntegrityKey, 0, 1*256);
	System.arraycopy(data, offset+996, lenUnknown1000, 0, 4);
	System.arraycopy(data, offset+1000, unknown1000, 0, 1*256);
	System.arraycopy(data, offset+1256, decryptedDataLength, 0, 8);
	System.arraycopy(data, offset+1264, possibleHeaderVersion, 0, 4);
	System.arraycopy(data, offset+1268, signature, 0, 1*8);
    }
    
    public static int length() { return STRUCTSIZE; }
    
    /** Unknown data. */
    public byte[] getUnknown0() { return Util.readByteArrayBE(unknown0); }
    /** Block size of the encrypted block data. */
    public int getBlockSize() { return Util.readIntBE(blockSize); }
    /** Unknown integer. */
    public int getUnknownInt20() { return Util.readIntBE(unknownInt20); }
    /** Unknown integer. */
    public int getUnknownInt24() { return Util.readIntBE(unknownInt24); }
    /** Unknown integer. */
    public int getUnknownInt28() { return Util.readIntBE(unknownInt28); }
    /** Unknown integer. */
    public int getUnknownInt32() { return Util.readIntBE(unknownInt32); }
    /** Unknown integer. */
    public int getUnknownInt36() { return Util.readIntBE(unknownInt36); }
    /** Unknown integer. */
    public int getUnknownInt40() { return Util.readIntBE(unknownInt40); }
    /** Unknown integer. */
    public int getUnknownInt44() { return Util.readIntBE(unknownInt44); }
    /** Iteration count for the key derivation function (normally 1000). */
    public int getKdfIterationCount() { return Util.readIntBE(kdfIterationCount); }
    /** Length of kdfSalt in bytes. */
    public int getKdfSaltLen() { return Util.readIntBE(kdfSaltLen); }
    /** Salt value for the key derivation function */
    public byte[] getKdfSalt() { return Util.readByteArrayBE(kdfSalt); }
    /** Unknown variable with observed value 16/0x10. */
    public int getLaban() { return Util.readIntBE(laban); }
    /** Unknown variable with observed value 5/0x5. */
    public int getEdward() { return Util.readIntBE(edward); }
    /** Unknown variable with observed value 0x80000001. */
    public int getPalle() { return Util.readIntBE(palle); }
    /** Unknown variable with observed value 128/0x80. */
    public int getLisa() { return Util.readIntBE(lisa); }
    /** Initialization Vector for encryption-key unwrapping. */
    public byte[] getUnwrapIv() { return Util.readByteArrayBE(unwrapIv); }
    /** Length of wrappedAesKey in bytes (max 256). */
    public int getLenWrappedAesKey() { return Util.readIntBE(lenWrappedAesKey); }
    /** The AES key (wrapped). */
    public byte[] getWrappedAesKey() { return Util.readByteArrayBE(wrappedAesKey); }
    /** Unknown integer (observed value: 91/0x5B). */
    public int getUnknownInt396() { return Util.readIntBE(unknownInt396); }
    /** Unknown integer (observed value: 160/0xA0). */
    public int getUnknownInt400() { return Util.readIntBE(unknownInt400); }
    /** Unknown data (observed: 8 bytes filled, rest 0). */
    public byte[] getUnknown404() { return Util.readByteArrayBE(unknown404); }
    /** Length of wrappedHmacSha1Key in bytes (max 256). */
    public int getLenWrappedHmacSha1Key() { return Util.readIntBE(lenWrappedHmacSha1Key); }
    /** The HMAC SHA-1 key (wrapped). */
    public byte[] getWrappedHmacSha1Key() { return Util.readByteArrayBE(wrappedHmacSha1Key); }
    /** Unknown integer (observed value: 91/0x5B). */
    public int getUnknownInt696() { return Util.readIntBE(unknownInt696); }
    /** Unknown integer (observed value: 160/0xA0). */
    public int getUnknownInt700() { return Util.readIntBE(unknownInt700); }
    /** Unknown data (obs. 8 bytes filled, rest 0). */
    public byte[] getUnknown704() { return Util.readByteArrayBE(unknown704); }
    /** Length of wrappedIntegrityKey. */
    public int getLenWrappedIntegrityKey() { return Util.readIntBE(lenWrappedIntegrityKey); }
    /** Integrity key. */
    public byte[] getWrappedIntegrityKey() { return Util.readByteArrayBE(wrappedIntegrityKey); }
    /** Length of unknown1000. */
    public int getLenUnknown1000() { return Util.readIntBE(lenUnknown1000); }
    /** Unknown key-like field with length specified by unknownRnd95GaLen (max 256). */
    public byte[] getUnknown1000() { return Util.readByteArrayBE(unknown1000); }
    /** Length in bytes of the underlying data stream. */
    public long getDecryptedDataLength() { return Util.readLongBE(decryptedDataLength); }
    /** Could be a variable indicating header version (observed: 1/0x1). */
    public int getPossibleHeaderVersion() { return Util.readIntBE(possibleHeaderVersion); }
    /** Header signature (ASCII: 'cdsaencr'). */
    public byte[] getSignature() { return Util.readByteArrayBE(signature); }
    
    public void printFields(PrintStream ps, String prefix) {
	ps.println(prefix + " unknown0: " + getUnknown0());
	ps.println(prefix + " blockSize: " + getBlockSize());
	ps.println(prefix + " unknownInt20: " + getUnknownInt20());
	ps.println(prefix + " unknownInt24: " + getUnknownInt24());
	ps.println(prefix + " unknownInt28: " + getUnknownInt28());
	ps.println(prefix + " unknownInt32: " + getUnknownInt32());
	ps.println(prefix + " unknownInt36: " + getUnknownInt36());
	ps.println(prefix + " unknownInt40: " + getUnknownInt40());
	ps.println(prefix + " unknownInt44: " + getUnknownInt44());
	ps.println(prefix + " kdfIterationCount: " + getKdfIterationCount());
	ps.println(prefix + " kdfSaltLen: " + getKdfSaltLen());
	ps.println(prefix + " kdfSalt: " + getKdfSalt());
	ps.println(prefix + " laban: " + getLaban());
	ps.println(prefix + " edward: " + getEdward());
	ps.println(prefix + " palle: " + getPalle());
	ps.println(prefix + " lisa: " + getLisa());
	ps.println(prefix + " unwrapIv: " + getUnwrapIv());
	ps.println(prefix + " lenWrappedAesKey: " + getLenWrappedAesKey());
	ps.println(prefix + " wrappedAesKey: " + getWrappedAesKey());
	ps.println(prefix + " unknownInt396: " + getUnknownInt396());
	ps.println(prefix + " unknownInt400: " + getUnknownInt400());
	ps.println(prefix + " unknown404: " + getUnknown404());
	ps.println(prefix + " lenWrappedHmacSha1Key: " + getLenWrappedHmacSha1Key());
	ps.println(prefix + " wrappedHmacSha1Key: " + getWrappedHmacSha1Key());
	ps.println(prefix + " unknownInt696: " + getUnknownInt696());
	ps.println(prefix + " unknownInt700: " + getUnknownInt700());
	ps.println(prefix + " unknown704: " + getUnknown704());
	ps.println(prefix + " lenWrappedIntegrityKey: " + getLenWrappedIntegrityKey());
	ps.println(prefix + " wrappedIntegrityKey: " + getWrappedIntegrityKey());
	ps.println(prefix + " lenUnknown1000: " + getLenUnknown1000());
	ps.println(prefix + " unknown1000: " + getUnknown1000());
	ps.println(prefix + " decryptedDataLength: " + getDecryptedDataLength());
	ps.println(prefix + " possibleHeaderVersion: " + getPossibleHeaderVersion());
	ps.println(prefix + " signature: " + getSignature());
    }
    
    public void print(PrintStream ps, String prefix) {
	ps.println(prefix + "ExperimentalV1Header:");
	printFields(ps, prefix);
    }
    
    public byte[] getBytes() {
	byte[] result = new byte[length()];
	int offset = 0;
	System.arraycopy(this.unknown0, 0, result, offset, this.unknown0.length); offset += this.unknown0.length;
	System.arraycopy(this.blockSize, 0, result, offset, this.blockSize.length); offset += this.blockSize.length;
	System.arraycopy(this.unknownInt20, 0, result, offset, this.unknownInt20.length); offset += this.unknownInt20.length;
	System.arraycopy(this.unknownInt24, 0, result, offset, this.unknownInt24.length); offset += this.unknownInt24.length;
	System.arraycopy(this.unknownInt28, 0, result, offset, this.unknownInt28.length); offset += this.unknownInt28.length;
	System.arraycopy(this.unknownInt32, 0, result, offset, this.unknownInt32.length); offset += this.unknownInt32.length;
	System.arraycopy(this.unknownInt36, 0, result, offset, this.unknownInt36.length); offset += this.unknownInt36.length;
	System.arraycopy(this.unknownInt40, 0, result, offset, this.unknownInt40.length); offset += this.unknownInt40.length;
	System.arraycopy(this.unknownInt44, 0, result, offset, this.unknownInt44.length); offset += this.unknownInt44.length;
	System.arraycopy(this.kdfIterationCount, 0, result, offset, this.kdfIterationCount.length); offset += this.kdfIterationCount.length;
	System.arraycopy(this.kdfSaltLen, 0, result, offset, this.kdfSaltLen.length); offset += this.kdfSaltLen.length;
	System.arraycopy(this.kdfSalt, 0, result, offset, this.kdfSalt.length); offset += this.kdfSalt.length;
	System.arraycopy(this.laban, 0, result, offset, this.laban.length); offset += this.laban.length;
	System.arraycopy(this.edward, 0, result, offset, this.edward.length); offset += this.edward.length;
	System.arraycopy(this.palle, 0, result, offset, this.palle.length); offset += this.palle.length;
	System.arraycopy(this.lisa, 0, result, offset, this.lisa.length); offset += this.lisa.length;
	System.arraycopy(this.unwrapIv, 0, result, offset, this.unwrapIv.length); offset += this.unwrapIv.length;
	System.arraycopy(this.lenWrappedAesKey, 0, result, offset, this.lenWrappedAesKey.length); offset += this.lenWrappedAesKey.length;
	System.arraycopy(this.wrappedAesKey, 0, result, offset, this.wrappedAesKey.length); offset += this.wrappedAesKey.length;
	System.arraycopy(this.unknownInt396, 0, result, offset, this.unknownInt396.length); offset += this.unknownInt396.length;
	System.arraycopy(this.unknownInt400, 0, result, offset, this.unknownInt400.length); offset += this.unknownInt400.length;
	System.arraycopy(this.unknown404, 0, result, offset, this.unknown404.length); offset += this.unknown404.length;
	System.arraycopy(this.lenWrappedHmacSha1Key, 0, result, offset, this.lenWrappedHmacSha1Key.length); offset += this.lenWrappedHmacSha1Key.length;
	System.arraycopy(this.wrappedHmacSha1Key, 0, result, offset, this.wrappedHmacSha1Key.length); offset += this.wrappedHmacSha1Key.length;
	System.arraycopy(this.unknownInt696, 0, result, offset, this.unknownInt696.length); offset += this.unknownInt696.length;
	System.arraycopy(this.unknownInt700, 0, result, offset, this.unknownInt700.length); offset += this.unknownInt700.length;
	System.arraycopy(this.unknown704, 0, result, offset, this.unknown704.length); offset += this.unknown704.length;
	System.arraycopy(this.lenWrappedIntegrityKey, 0, result, offset, this.lenWrappedIntegrityKey.length); offset += this.lenWrappedIntegrityKey.length;
	System.arraycopy(this.wrappedIntegrityKey, 0, result, offset, this.wrappedIntegrityKey.length); offset += this.wrappedIntegrityKey.length;
	System.arraycopy(this.lenUnknown1000, 0, result, offset, this.lenUnknown1000.length); offset += this.lenUnknown1000.length;
	System.arraycopy(this.unknown1000, 0, result, offset, this.unknown1000.length); offset += this.unknown1000.length;
	System.arraycopy(this.decryptedDataLength, 0, result, offset, this.decryptedDataLength.length); offset += this.decryptedDataLength.length;
	System.arraycopy(this.possibleHeaderVersion, 0, result, offset, this.possibleHeaderVersion.length); offset += this.possibleHeaderVersion.length;
	System.arraycopy(this.signature, 0, result, offset, this.signature.length); offset += this.signature.length;
	return result;
    }
}
