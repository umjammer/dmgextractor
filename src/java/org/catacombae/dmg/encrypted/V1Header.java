/*-
 * Copyright (C) 2008 Erik Larsson
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * This code was written from studying vfdecrypt, Copyright (c) 2006
 *   Ralf-Philipp Weinmann <ralf@coderpunks.org>
 *   Jacob Appelbaum <jacob@appelbaum.net>
 *   Christian Fromme <kaner@strace.org>
 *
 * [I'm not sure if their copyright and license terms need to be applied,
 *  but in case they do, the original license terms are reprinted below
 *  as required by the license.]
 *
 * The vfdecrypt license says:
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 */

package org.catacombae.dmg.encrypted;

import java.io.PrintStream;
import org.catacombae.dmgextractor.Util;

/** This class was generated by CStructToJavaClass. */
public class V1Header {
    /*
     * struct V1Header
     * size: 1276 bytes
     * description:
     *
     * BP    Size   Type          Identifier              Description
     * -------------------------------------------------------------------------------------------------------------------------------
     * 0     1*16   uint8_t[16]   unknown0                Unknown data.
     * 16    4      uint32_t      blockSize               Block size of the encrypted block data.
     * 20    4      uint32_t      unknownInt20            Unknown integer.
     * 24    4      uint32_t      unknownInt24            Unknown integer.
     * 28    4      uint32_t      unknownInt28            Unknown integer.
     * 32    4      uint32_t      unknownInt32            Unknown integer.
     * 36    4      uint32_t      unknownInt36            Unknown integer.
     * 40    4      uint32_t      unknownInt40            Unknown integer.
     * 44    4      uint32_t      unknownInt44            Unknown integer.
     * 48    4      uint32_t      kdfIterationCount       Iteration count for the key derivation function (normally 1000).
     * 52    4      uint32_t      kdfSaltLen              Length of kdfSalt in bytes.
     * 56    1*32   uint8_t[32]   kdfSalt                 Salt value for the key derivation function
     * 88    4      uint32_t      unknownInt88            Unknown integer.
     * 92    4      uint32_t      unknownInt92            Unknown integer.
     * 96    4      uint32_t      unknownInt96            Unknown integer.
     * 100   4      uint32_t      unknownInt100           Unknown integer.
     * 104   1*32   uint8_t[32]   unwrapIv                Initialization Vector for encryption-key unwrapping.
     * 136   4      uint32_t      lenWrappedAesKey        Length of wrappedAesKey in bytes (max 256).
     * 140   1*256  uint8_t[256]  wrappedAesKey           The AES key (wrapped).
     * 396   4      uint32_t      unknownInt396           Unknown integer (observed value: 91/0x5B).
     * 400   4      uint32_t      unknownInt400           Unknown integer (observed value: 160/0xA0).
     * 404   1*32   uint8_t[32]   unknown404              Unknown data (observed: 8 bytes filled, rest 0).
     * 436   4      uint32_t      lenWrappedHmacSha1Key   Length of wrappedHmacSha1Key in bytes (max 256).
     * 440   1*256  uint8_t[256]  wrappedHmacSha1Key      The HMAC SHA-1 key (wrapped).
     * 696   4      uint32_t      unknownInt696           Unknown integer (observed value: 91/0x5B).
     * 700   4      uint32_t      unknownInt700           Unknown integer (observed value: 160/0xA0).
     * 704   1*32   uint8_t[32]   unknown704              Unknown data (obs. 8 bytes filled, rest 0).
     * 736   4      uint32_t      lenWrappedIntegrityKey  Length of wrappedIntegrityKey.
     * 740   1*256  uint8_t[256]  wrappedIntegrityKey     Integrity key.
     * 996   4      uint32_t      lenUnknown1000          Length of unknown1000.
     * 1000  1*256  uint8_t[256]  unknown1000             Unknown key-like field with length specified by unknownRnd95GaLen (max 256).
     * 1256  8      uint64_t      decryptedDataLength     Length in bytes of the underlying data stream.
     * 1264  4      uint32_t      possibleHeaderVersion   Could be a variable indicating header version (observed: 1/0x1).
     * 1268  1*8    uint8_t[8]    signature               Header signature (ASCII: 'cdsaencr').
     */

    public static final int STRUCTSIZE = 1276;

    private final byte[] unknown0 = new byte[1*16];
    private final byte[] blockSize = new byte[4];
    private final byte[] unknownInt20 = new byte[4];
    private final byte[] unknownInt24 = new byte[4];
    private final byte[] unknownInt28 = new byte[4];
    private final byte[] unknownInt32 = new byte[4];
    private final byte[] unknownInt36 = new byte[4];
    private final byte[] unknownInt40 = new byte[4];
    private final byte[] unknownInt44 = new byte[4];
    private final byte[] kdfIterationCount = new byte[4];
    private final byte[] kdfSaltLen = new byte[4];
    private final byte[] kdfSalt = new byte[1*32];
    private final byte[] unknownInt88 = new byte[4];
    private final byte[] unknownInt92 = new byte[4];
    private final byte[] unknownInt96 = new byte[4];
    private final byte[] unknownInt100 = new byte[4];
    private final byte[] unwrapIv = new byte[1*32];
    private final byte[] lenWrappedAesKey = new byte[4];
    private final byte[] wrappedAesKey = new byte[1*256];
    private final byte[] unknownInt396 = new byte[4];
    private final byte[] unknownInt400 = new byte[4];
    private final byte[] unknown404 = new byte[1*32];
    private final byte[] lenWrappedHmacSha1Key = new byte[4];
    private final byte[] wrappedHmacSha1Key = new byte[1*256];
    private final byte[] unknownInt696 = new byte[4];
    private final byte[] unknownInt700 = new byte[4];
    private final byte[] unknown704 = new byte[1*32];
    private final byte[] lenWrappedIntegrityKey = new byte[4];
    private final byte[] wrappedIntegrityKey = new byte[1*256];
    private final byte[] lenUnknown1000 = new byte[4];
    private final byte[] unknown1000 = new byte[1*256];
    private final byte[] decryptedDataLength = new byte[8];
    private final byte[] possibleHeaderVersion = new byte[4];
    private final byte[] signature = new byte[1*8];

    public V1Header(byte[] data, int offset) {
	System.arraycopy(data, offset+0, unknown0, 0, 1*16);
	System.arraycopy(data, offset+16, blockSize, 0, 4);
	System.arraycopy(data, offset+20, unknownInt20, 0, 4);
	System.arraycopy(data, offset+24, unknownInt24, 0, 4);
	System.arraycopy(data, offset+28, unknownInt28, 0, 4);
	System.arraycopy(data, offset+32, unknownInt32, 0, 4);
	System.arraycopy(data, offset+36, unknownInt36, 0, 4);
	System.arraycopy(data, offset+40, unknownInt40, 0, 4);
	System.arraycopy(data, offset+44, unknownInt44, 0, 4);
	System.arraycopy(data, offset+48, kdfIterationCount, 0, 4);
	System.arraycopy(data, offset+52, kdfSaltLen, 0, 4);
	System.arraycopy(data, offset+56, kdfSalt, 0, 1*32);
	System.arraycopy(data, offset+88, unknownInt88, 0, 4);
	System.arraycopy(data, offset+92, unknownInt92, 0, 4);
	System.arraycopy(data, offset+96, unknownInt96, 0, 4);
	System.arraycopy(data, offset+100, unknownInt100, 0, 4);
	System.arraycopy(data, offset+104, unwrapIv, 0, 1*32);
	System.arraycopy(data, offset+136, lenWrappedAesKey, 0, 4);
	System.arraycopy(data, offset+140, wrappedAesKey, 0, 1*256);
	System.arraycopy(data, offset+396, unknownInt396, 0, 4);
	System.arraycopy(data, offset+400, unknownInt400, 0, 4);
	System.arraycopy(data, offset+404, unknown404, 0, 1*32);
	System.arraycopy(data, offset+436, lenWrappedHmacSha1Key, 0, 4);
	System.arraycopy(data, offset+440, wrappedHmacSha1Key, 0, 1*256);
	System.arraycopy(data, offset+696, unknownInt696, 0, 4);
	System.arraycopy(data, offset+700, unknownInt700, 0, 4);
	System.arraycopy(data, offset+704, unknown704, 0, 1*32);
	System.arraycopy(data, offset+736, lenWrappedIntegrityKey, 0, 4);
	System.arraycopy(data, offset+740, wrappedIntegrityKey, 0, 1*256);
	System.arraycopy(data, offset+996, lenUnknown1000, 0, 4);
	System.arraycopy(data, offset+1000, unknown1000, 0, 1*256);
	System.arraycopy(data, offset+1256, decryptedDataLength, 0, 8);
	System.arraycopy(data, offset+1264, possibleHeaderVersion, 0, 4);
	System.arraycopy(data, offset+1268, signature, 0, 1*8);
    }

    public static int length() { return STRUCTSIZE; }

    /** Unknown data. */
    public byte[] getUnknown0() { return Util.readByteArrayBE(unknown0); }
    /** Block size of the encrypted block data. */
    public int getBlockSize() { return Util.readIntBE(blockSize); }
    /** Unknown integer. */
    public int getUnknownInt20() { return Util.readIntBE(unknownInt20); }
    /** Unknown integer. */
    public int getUnknownInt24() { return Util.readIntBE(unknownInt24); }
    /** Unknown integer. */
    public int getUnknownInt28() { return Util.readIntBE(unknownInt28); }
    /** Unknown integer. */
    public int getUnknownInt32() { return Util.readIntBE(unknownInt32); }
    /** Unknown integer. */
    public int getUnknownInt36() { return Util.readIntBE(unknownInt36); }
    /** Unknown integer. */
    public int getUnknownInt40() { return Util.readIntBE(unknownInt40); }
    /** Unknown integer. */
    public int getUnknownInt44() { return Util.readIntBE(unknownInt44); }
    /** Iteration count for the key derivation function (normally 1000). */
    public int getKdfIterationCount() { return Util.readIntBE(kdfIterationCount); }
    /** Length of kdfSalt in bytes. */
    public int getKdfSaltLen() { return Util.readIntBE(kdfSaltLen); }
    /** Salt value for the key derivation function */
    public byte[] getKdfSalt() { return Util.readByteArrayBE(kdfSalt); }
    /** Unknown integer. */
    public int getUnknownInt88() { return Util.readIntBE(unknownInt88); }
    /** Unknown integer. */
    public int getUnknownInt92() { return Util.readIntBE(unknownInt92); }
    /** Unknown integer. */
    public int getUnknownInt96() { return Util.readIntBE(unknownInt96); }
    /** Unknown integer. */
    public int getUnknownInt100() { return Util.readIntBE(unknownInt100); }
    /** Initialization Vector for encryption-key unwrapping. */
    public byte[] getUnwrapIv() { return Util.readByteArrayBE(unwrapIv); }
    /** Length of wrappedAesKey in bytes (max 256). */
    public int getLenWrappedAesKey() { return Util.readIntBE(lenWrappedAesKey); }
    /** The AES key (wrapped). */
    public byte[] getWrappedAesKey() { return Util.readByteArrayBE(wrappedAesKey); }
    /** Unknown integer (observed value: 91/0x5B). */
    public int getUnknownInt396() { return Util.readIntBE(unknownInt396); }
    /** Unknown integer (observed value: 160/0xA0). */
    public int getUnknownInt400() { return Util.readIntBE(unknownInt400); }
    /** Unknown data (observed: 8 bytes filled, rest 0). */
    public byte[] getUnknown404() { return Util.readByteArrayBE(unknown404); }
    /** Length of wrappedHmacSha1Key in bytes (max 256). */
    public int getLenWrappedHmacSha1Key() { return Util.readIntBE(lenWrappedHmacSha1Key); }
    /** The HMAC SHA-1 key (wrapped). */
    public byte[] getWrappedHmacSha1Key() { return Util.readByteArrayBE(wrappedHmacSha1Key); }
    /** Unknown integer (observed value: 91/0x5B). */
    public int getUnknownInt696() { return Util.readIntBE(unknownInt696); }
    /** Unknown integer (observed value: 160/0xA0). */
    public int getUnknownInt700() { return Util.readIntBE(unknownInt700); }
    /** Unknown data (obs. 8 bytes filled, rest 0). */
    public byte[] getUnknown704() { return Util.readByteArrayBE(unknown704); }
    /** Length of wrappedIntegrityKey. */
    public int getLenWrappedIntegrityKey() { return Util.readIntBE(lenWrappedIntegrityKey); }
    /** Integrity key. */
    public byte[] getWrappedIntegrityKey() { return Util.readByteArrayBE(wrappedIntegrityKey); }
    /** Length of unknown1000. */
    public int getLenUnknown1000() { return Util.readIntBE(lenUnknown1000); }
    /** Unknown key-like field with length specified by unknownRnd95GaLen (max 256). */
    public byte[] getUnknown1000() { return Util.readByteArrayBE(unknown1000); }
    /** Length in bytes of the underlying data stream. */
    public long getDecryptedDataLength() { return Util.readLongBE(decryptedDataLength); }
    /** Could be a variable indicating header version (observed: 1/0x1). */
    public int getPossibleHeaderVersion() { return Util.readIntBE(possibleHeaderVersion); }
    /** Header signature (ASCII: 'cdsaencr'). */
    public byte[] getSignature() { return Util.readByteArrayBE(signature); }

    public void printFields(PrintStream ps, String prefix) {
	ps.println(prefix + " unknown0: 0x" + Util.byteArrayToHexString(getUnknown0()));
	ps.println(prefix + " blockSize: " + Util.unsign(getBlockSize()));
	ps.println(prefix + " unknownInt20: " + getUnknownInt20());
	ps.println(prefix + " unknownInt24: " + getUnknownInt24());
	ps.println(prefix + " unknownInt28: " + getUnknownInt28());
	ps.println(prefix + " unknownInt32: " + getUnknownInt32());
	ps.println(prefix + " unknownInt36: " + getUnknownInt36());
	ps.println(prefix + " unknownInt40: " + getUnknownInt40());
	ps.println(prefix + " unknownInt44: " + getUnknownInt44());
	ps.println(prefix + " kdfIterationCount: " + Util.unsign(getKdfIterationCount()));
	ps.println(prefix + " kdfSaltLen: " + Util.unsign(getKdfSaltLen()));
	ps.println(prefix + " kdfSalt: 0x" + Util.byteArrayToHexString(getKdfSalt()));
	ps.println(prefix + " unknownInt88: " + getUnknownInt88());
	ps.println(prefix + " unknownInt92: " + getUnknownInt92());
	ps.println(prefix + " unknownInt96: " + getUnknownInt96());
	ps.println(prefix + " unknownInt100: " + getUnknownInt100());
	ps.println(prefix + " unwrapIv: 0x" + Util.byteArrayToHexString(getUnwrapIv()));
	ps.println(prefix + " lenWrappedAesKey: " + Util.unsign(getLenWrappedAesKey()));
	ps.println(prefix + " wrappedAesKey: 0x" + Util.byteArrayToHexString(getWrappedAesKey()));
	ps.println(prefix + " unknownInt396: " + getUnknownInt396());
	ps.println(prefix + " unknownInt400: " + getUnknownInt400());
	ps.println(prefix + " unknown404: 0x" + Util.byteArrayToHexString(getUnknown404()));
	ps.println(prefix + " lenWrappedHmacSha1Key: " + Util.unsign(getLenWrappedHmacSha1Key()));
	ps.println(prefix + " wrappedHmacSha1Key: 0x" + Util.byteArrayToHexString(getWrappedHmacSha1Key()));
	ps.println(prefix + " unknownInt696: " + getUnknownInt696());
	ps.println(prefix + " unknownInt700: " + getUnknownInt700());
	ps.println(prefix + " unknown704: 0x" + Util.byteArrayToHexString(getUnknown704()));
	ps.println(prefix + " lenWrappedIntegrityKey: " + Util.unsign(getLenWrappedIntegrityKey()));
	ps.println(prefix + " wrappedIntegrityKey: 0x" + Util.byteArrayToHexString(getWrappedIntegrityKey()));
	ps.println(prefix + " lenUnknown1000: " + getLenUnknown1000());
	ps.println(prefix + " unknown1000: 0x" + Util.byteArrayToHexString(getUnknown1000()));
	ps.println(prefix + " decryptedDataLength: " + getDecryptedDataLength());
	ps.println(prefix + " possibleHeaderVersion: " + getPossibleHeaderVersion());
	ps.println(prefix + " signature: \"" + Util.toASCIIString(getSignature()) + "\"");
    }
    
    public void print(PrintStream ps, String prefix) {
	ps.println(prefix + "V1Header:");
	printFields(ps, prefix);
    }
    
    public byte[] getBytes() {
	byte[] result = new byte[length()];
	int offset = 0;
	System.arraycopy(this.unknown0, 0, result, offset, this.unknown0.length); offset += this.unknown0.length;
	System.arraycopy(this.blockSize, 0, result, offset, this.blockSize.length); offset += this.blockSize.length;
	System.arraycopy(this.unknownInt20, 0, result, offset, this.unknownInt20.length); offset += this.unknownInt20.length;
	System.arraycopy(this.unknownInt24, 0, result, offset, this.unknownInt24.length); offset += this.unknownInt24.length;
	System.arraycopy(this.unknownInt28, 0, result, offset, this.unknownInt28.length); offset += this.unknownInt28.length;
	System.arraycopy(this.unknownInt32, 0, result, offset, this.unknownInt32.length); offset += this.unknownInt32.length;
	System.arraycopy(this.unknownInt36, 0, result, offset, this.unknownInt36.length); offset += this.unknownInt36.length;
	System.arraycopy(this.unknownInt40, 0, result, offset, this.unknownInt40.length); offset += this.unknownInt40.length;
	System.arraycopy(this.unknownInt44, 0, result, offset, this.unknownInt44.length); offset += this.unknownInt44.length;
	System.arraycopy(this.kdfIterationCount, 0, result, offset, this.kdfIterationCount.length); offset += this.kdfIterationCount.length;
	System.arraycopy(this.kdfSaltLen, 0, result, offset, this.kdfSaltLen.length); offset += this.kdfSaltLen.length;
	System.arraycopy(this.kdfSalt, 0, result, offset, this.kdfSalt.length); offset += this.kdfSalt.length;
	System.arraycopy(this.unknownInt88, 0, result, offset, this.unknownInt88.length); offset += this.unknownInt88.length;
	System.arraycopy(this.unknownInt92, 0, result, offset, this.unknownInt92.length); offset += this.unknownInt92.length;
	System.arraycopy(this.unknownInt96, 0, result, offset, this.unknownInt96.length); offset += this.unknownInt96.length;
	System.arraycopy(this.unknownInt100, 0, result, offset, this.unknownInt100.length); offset += this.unknownInt100.length;
	System.arraycopy(this.unwrapIv, 0, result, offset, this.unwrapIv.length); offset += this.unwrapIv.length;
	System.arraycopy(this.lenWrappedAesKey, 0, result, offset, this.lenWrappedAesKey.length); offset += this.lenWrappedAesKey.length;
	System.arraycopy(this.wrappedAesKey, 0, result, offset, this.wrappedAesKey.length); offset += this.wrappedAesKey.length;
	System.arraycopy(this.unknownInt396, 0, result, offset, this.unknownInt396.length); offset += this.unknownInt396.length;
	System.arraycopy(this.unknownInt400, 0, result, offset, this.unknownInt400.length); offset += this.unknownInt400.length;
	System.arraycopy(this.unknown404, 0, result, offset, this.unknown404.length); offset += this.unknown404.length;
	System.arraycopy(this.lenWrappedHmacSha1Key, 0, result, offset, this.lenWrappedHmacSha1Key.length); offset += this.lenWrappedHmacSha1Key.length;
	System.arraycopy(this.wrappedHmacSha1Key, 0, result, offset, this.wrappedHmacSha1Key.length); offset += this.wrappedHmacSha1Key.length;
	System.arraycopy(this.unknownInt696, 0, result, offset, this.unknownInt696.length); offset += this.unknownInt696.length;
	System.arraycopy(this.unknownInt700, 0, result, offset, this.unknownInt700.length); offset += this.unknownInt700.length;
	System.arraycopy(this.unknown704, 0, result, offset, this.unknown704.length); offset += this.unknown704.length;
	System.arraycopy(this.lenWrappedIntegrityKey, 0, result, offset, this.lenWrappedIntegrityKey.length); offset += this.lenWrappedIntegrityKey.length;
	System.arraycopy(this.wrappedIntegrityKey, 0, result, offset, this.wrappedIntegrityKey.length); offset += this.wrappedIntegrityKey.length;
	System.arraycopy(this.lenUnknown1000, 0, result, offset, this.lenUnknown1000.length); offset += this.lenUnknown1000.length;
	System.arraycopy(this.unknown1000, 0, result, offset, this.unknown1000.length); offset += this.unknown1000.length;
	System.arraycopy(this.decryptedDataLength, 0, result, offset, this.decryptedDataLength.length); offset += this.decryptedDataLength.length;
	System.arraycopy(this.possibleHeaderVersion, 0, result, offset, this.possibleHeaderVersion.length); offset += this.possibleHeaderVersion.length;
	System.arraycopy(this.signature, 0, result, offset, this.signature.length); offset += this.signature.length;
	return result;
    }
}
