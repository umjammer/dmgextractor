/*-
 * Copyright (C) 2008 Erik Larsson
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * This code was written from studying vfdecrypt, Copyright (c) 2006
 *   Ralf-Philipp Weinmann <ralf@coderpunks.org>
 *   Jacob Appelbaum <jacob@appelbaum.net>
 *   Christian Fromme <kaner@strace.org>
 *
 * [I'm not sure if their copyright and license terms need to be applied,
 *  but in case they do, the original license terms are reprinted below
 *  as required by the license.]
 *
 * The vfdecrypt license says:
 *   Permission is hereby granted, free of charge, to any person
 *   obtaining a copy of this software and associated documentation
 *   files (the "Software"), to deal in the Software without
 *   restriction, including without limitation the rights to use,
 *   copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following
 *   conditions:
 *
 *   The above copyright notice and this permission notice shall be
 *   included in all copies or substantial portions of the Software.
 */

package org.catacombae.dmg.encrypted;

import java.io.PrintStream;
import org.catacombae.csjc.DynamicStruct;
import org.catacombae.csjc.PrintableStruct;
import org.catacombae.csjc.StaticStruct;
import org.catacombae.dmgextractor.Util;
import org.catacombae.io.ReadableRandomAccessStream;

/** This class was generated by CStructToJavaClass. */
public class V2Header {
    /*
     * struct V2Header
     * size: at least 76 bytes
     * description:
     *
     * BP   Size  Type            Identifier             Description
     * ------------------------------------------------------------------------------------------------------------
     * 0    8     uint8_t[8]      signature              Header signature
     *                                                   (ASCII: 'encrcdsa').
     * 8    4     uint32_t        possibleHeaderVersion  Possibly the version of
     *                                                   the encrypted volume
     *                                                   format.
     * 12   4     uint32_t        reservedAt12           Unknown variable with
     *                                                   observed value 16/0x10.
     * 16   4     uint32_t        reservedAt16           Unknown variable with
     *                                                   observed value 5/0x5.
     * 20   4     uint32_t        reservedAt20           Unknown variable with
     *                                                   observed value
     *                                                   0x80000001.
     * 24   4     uint32_t        keyBits                Number of bits in the
     *                                                   key.
     * 28   4     uint32_t        reservedAt28           Unknown variable with
     *                                                   observed value 91/0x5B.
     * 32   4     uint32_t        reservedAt32           Unknown variable with
     *                                                   observed value
     *                                                   160/0xA0.
     * 36   16    uint8_t[16]     reservedAt36           Unknown binary data.
     * 52   4     uint32_t        blockSize              Block size of the
     *                                                   encrypted block data.
     * 56   8     uint64_t        encryptedDataLength    Length in bytes of the
     *                                                   data that has been
     *                                                   encrypted.
     * 64   8     uint64_t        offsetToDataStart      Offset to the start of
     *                                                   the encrypted block
     *                                                   data.
     * 72   4     uint32_t        numberOfKeys           The number of keys in
     *                                                   the header.
     * 76   ?     KeyPointer[]    keyPointers            Array of pointers to
     *                                                   the header's key data
     *                                                   objects.
     * ?    ?     KeyData[]       keys                   Key data objects, laid
     *                                                   out according to the
     *                                                   key pointers.
     *
     * struct KeyPointer
     * size: 20 bytes
     * description:
     *
     * BP   Size  Type         Identifier  Description
     * -------------------------------------------------------------------------
     * 0    4     uint32_t     keyType     Key type.
     * 4    8     uint64_t     keyOffset   Offset from the start of the header
     *                                     to the key data.
     * 12   8     uint64_t     keyLength   Length of the key data.
     *
     * struct UserKeyData
     * size: at least 104 bytes
     * description:
     *
     * BP   Size  Type         Identifier            Description
     * -------------------------------------------------------------------------
     * 0    4     uint32_t     kdfAlgorithm          Algorithm of the key
     *                                               derivation function.
     * 4    4     uint32_t     kdfPrngAlgorithm      ?
     * 8    4     uint32_t     kdfIterationCount     Iteration count (normally
     *                                               1000).
     * 12   4     uint32_t     kdfSaltLen            Length of kdfSalt (in
     *                                               bytes).
     * 16   32    uint8_t[32]  kdfSalt               Salt value for key
     *                                               derivation.
     * 48   4     uint32_t     blobEncIvSize         Size of blobEncIv.
     * 52   32    uint8_t[32]  blobEncIv             Initialization Vector for
     *                                               encryption-key unwrapping.
     * 84   4     uint32_t     blobEncKeyBits        Number of bits in the
     *                                               keyblob's encryption key.
     * 88   4     uint32_t     blobEncAlgorithm      Encryption algorithm used
     *                                               to encrypt the key blob.
     * 92   4     uint32_t     blobEncPadding        Padding. (?)
     * 96   4     uint32_t     blobEncMode           Encryption mode for the
     *                                               algorithm.
     * 100  4     uint32_t     encryptedKeyblobSize  Size of encryptedKeyBlob.
     * 104  ?     uint8_t[?]   encryptedKeyblob      The encrypted key blob,
     *                                               containing all keys.
     *                                               The size of this data is
     *                                               specified in
     *                                               encryptedKeyblobSize.
     */

    public static final int STATIC_STRUCTSIZE = 76;

    private final byte[] signature = new byte[1*8];
    private final byte[] possibleHeaderVersion = new byte[4];
    private final byte[] reservedAt12 = new byte[4];
    private final byte[] reservedAt16 = new byte[4];
    private final byte[] reservedAt20 = new byte[4];
    private final byte[] keyBits = new byte[4];
    private final byte[] reservedAt28 = new byte[4];
    private final byte[] reservedAt32 = new byte[4];
    private final byte[] reservedAt36 = new byte[1*16];
    private final byte[] blockSize = new byte[4];
    private final byte[] encryptedDataLength = new byte[8];
    private final byte[] offsetToDataStart = new byte[8];
    private final byte[] numberOfKeys = new byte[4];
    private final KeyPointer[] keyPointers;
    private final KeyData[] keys;

    public V2Header(ReadableRandomAccessStream stream) {
        final long headerStartFilePointer = stream.getFilePointer();

        if((stream.length() - headerStartFilePointer) < STATIC_STRUCTSIZE) {
            throw new IllegalArgumentException("Not enough data for static " +
                    "V2 header fields.");
        }

        int offset = 0;

        stream.readFully(signature);
        offset += signature.length;

        stream.readFully(possibleHeaderVersion);
        offset += possibleHeaderVersion.length;

        stream.readFully(reservedAt12);
        if(getReservedAt12() != 16) {
            warning("Previously unseen value at offset " + offset + ": " +
                    getReservedAt12());
        }
        offset += reservedAt12.length;

        stream.readFully(reservedAt16);
        if(getReservedAt16() != 5) {
            warning("Previously unseen value at offset " + offset + ": " +
                    getReservedAt16());
        }
        offset += reservedAt16.length;

        stream.readFully(reservedAt20);
        if(getReservedAt20() != 0x80000001) {
            warning("Previously unseen value at offset " + offset + ": " +
                    getReservedAt20());
        }
        offset += reservedAt20.length;

        stream.readFully(keyBits);
        offset += keyBits.length;

        stream.readFully(reservedAt28);
        if(getReservedAt28() != 91) {
            warning("Previously unseen value at offset " + offset + ": " +
                    getReservedAt28());
        }
        offset += reservedAt28.length;

        stream.readFully(reservedAt32);
        if(getReservedAt32() != 160) {
            warning("Previously unseen value at offset " + offset + ": " +
                    getReservedAt32());
        }
        offset += reservedAt32.length;

        stream.readFully(reservedAt36);
        offset += reservedAt36.length;

        stream.readFully(blockSize);
        offset += blockSize.length;

        stream.readFully(encryptedDataLength);
        offset += encryptedDataLength.length;

        stream.readFully(offsetToDataStart);
        offset += offsetToDataStart.length;

        stream.readFully(numberOfKeys);
        offset += numberOfKeys.length;

        keyPointers = new KeyPointer[getNumberOfKeys()];
        keys = new KeyData[keyPointers.length];
        for(int i = 0; i < keyPointers.length; ++i) {
            stream.seek(headerStartFilePointer + offset);

            KeyPointer curPointer = new KeyPointer(stream);
            offset += KeyPointer.staticSize();

            long keyOffset = curPointer.getKeyOffset();
            long keyLength = curPointer.getKeyLength();

            if(keyOffset < offset) {
                throw new RuntimeException("Invalid layout: Key data is " +
                        "located before key pointers.");
            }
            else if(keyOffset > Integer.MAX_VALUE) {
                throw new RuntimeException("Invalid layout: Key offset is " +
                        "out of bounds for a 32-bit signed integer.");
            }
            else if(keyLength > Integer.MAX_VALUE) {
                throw new RuntimeException("Invalid layout: Key length is " +
                        "out of bounds for a 32-bit signed integer.");
            }

            KeyData curData;

            stream.seek(headerStartFilePointer + curPointer.getKeyOffset());
            if(curPointer.getKeyType() == 1) {
                curData = new UserKeyData(stream,
                        (int) curPointer.getKeyLength());
            }
            else {
                curData = new UnknownKeyData(stream,
                        (int) curPointer.getKeyLength());
            }

            keyPointers[i] = curPointer;
            keys[i] = curData;
        }
    }

    private static final void warning(String s) {
        System.err.println("[" + V2Header.class.getSimpleName() + "] " +
                "WARNING: " + s);
    }

    public int length() {
        int length =
                STATIC_STRUCTSIZE +
                keyPointers.length * KeyPointer.staticSize();
        for(KeyData kd : keys) {
            length += kd.occupiedSize();
        }

        return length;
    }

    /** Header signature (ASCII: 'encrcdsa'). */
    public byte[] getSignature() { return Util.readByteArrayBE(signature); }
    /** Possibly the version of the encrypted volume format. */
    public int getPossibleHeaderVersion() { return Util.readIntBE(possibleHeaderVersion); }

    /** Unknown variable with observed value 16/0x10. */
    public int getReservedAt12() {
        return Util.readIntBE(reservedAt12);
    }

    /** Unknown variable with observed value 5/0x5. */
    public int getReservedAt16() {
        return Util.readIntBE(reservedAt16);
    }

    /** Unknown variable with observed value 0x80000001. */
    public int getReservedAt20() {
        return Util.readIntBE(reservedAt20);
    }

    /**
     * Number of bits in the key (128 for AES-128 encrypted images, 256 for
     * AES-256, ...).
     */
    public int getKeyBits() { return Util.readIntBE(keyBits); }

    /** Unknown variable with observed value 91/0x5B. */
    public int getReservedAt28() {
        return Util.readIntBE(reservedAt28);
    }

    /** Unknown variable with observed value 160/0xA0. */
    public int getReservedAt32() {
        return Util.readIntBE(reservedAt32);
    }

    /** Unknown binary data. */
    public byte[] getReservedAt36() {
        return Util.readByteArrayBE(reservedAt36);
    }

    /** Block size of the encrypted block data. */
    public int getBlockSize() { return Util.readIntBE(blockSize); }
    /** Length in bytes of the data that has been encrypted. */
    public long getEncryptedDataLength() { return Util.readLongBE(encryptedDataLength); }
    /** Offset to the start of the encrypted block data. */
    public long getOffsetToDataStart() { return Util.readLongBE(offsetToDataStart); }

    /** The number of keys in this header. */
    public int getNumberOfKeys() {
        return Util.readIntBE(numberOfKeys);
    }

    public KeyPointer[] getKeyPointers() {
        return Util.arrayCopy(keyPointers, new KeyPointer[keyPointers.length]);
    }

    public KeyData[] getKeys() {
        return Util.arrayCopy(keys, new KeyData[keys.length]);
    }

    public void printFields(PrintStream ps, String prefix) {
	ps.println(prefix + " signature: \"" + Util.toASCIIString(getSignature()) + "\"");
	ps.println(prefix + " possibleHeaderVersion: " + getPossibleHeaderVersion());
	ps.println(prefix + " reservedAt12: " + getReservedAt12());
	ps.println(prefix + " reservedAt16: " + getReservedAt16());
	ps.println(prefix + " reservedAt20: " + getReservedAt20());
	ps.println(prefix + " keyBits: " + getKeyBits());
	ps.println(prefix + " reservedAt28: " + getReservedAt28());
	ps.println(prefix + " reservedAt32: " + getReservedAt32());
	ps.println(prefix + " reservedAt36: " +
                "0x" + Util.byteArrayToHexString(reservedAt36));
	ps.println(prefix + " blockSize: " + getBlockSize());
	ps.println(prefix + " encryptedDataLength: " + getEncryptedDataLength());
	ps.println(prefix + " offsetToDataStart: " + getOffsetToDataStart());
	ps.println(prefix + " numberOfKeys: " + getNumberOfKeys());

        for(int i = 0; i < keyPointers.length; ++i) {
            ps.println(prefix + " keyPointers[" + i + "]:");
            keyPointers[i].printFields(ps, prefix + "  ");
        }

        for(int i = 0; i < keys.length; ++i) {
            ps.println(prefix + " keys[" + i + "]:");
            keys[i].printFields(ps, prefix + "  ");
        }
    }

    public void print(PrintStream ps, String prefix) {
	ps.println(prefix + "V2Header:");
	printFields(ps, prefix);
    }

    public byte[] getBytes() {
	byte[] result = new byte[length()];
	int offset = 0;
	System.arraycopy(this.signature, 0, result, offset, this.signature.length); offset += this.signature.length;
	System.arraycopy(this.possibleHeaderVersion, 0, result, offset, this.possibleHeaderVersion.length); offset += this.possibleHeaderVersion.length;
	System.arraycopy(this.reservedAt12, 0, result, offset, this.reservedAt12.length); offset += this.reservedAt12.length;
	System.arraycopy(this.reservedAt16, 0, result, offset, this.reservedAt16.length); offset += this.reservedAt16.length;
	System.arraycopy(this.reservedAt20, 0, result, offset, this.reservedAt20.length); offset += this.reservedAt20.length;
	System.arraycopy(this.keyBits, 0, result, offset, this.keyBits.length); offset += this.keyBits.length;
	System.arraycopy(this.reservedAt28, 0, result, offset, this.reservedAt28.length); offset += this.reservedAt28.length;
	System.arraycopy(this.reservedAt32, 0, result, offset, this.reservedAt32.length); offset += this.reservedAt32.length;
	System.arraycopy(this.reservedAt36, 0, result, offset, this.reservedAt36.length); offset += this.reservedAt36.length;
	System.arraycopy(this.blockSize, 0, result, offset, this.blockSize.length); offset += this.blockSize.length;
	System.arraycopy(this.encryptedDataLength, 0, result, offset, this.encryptedDataLength.length); offset += this.encryptedDataLength.length;
	System.arraycopy(this.offsetToDataStart, 0, result, offset, this.offsetToDataStart.length); offset += this.offsetToDataStart.length;

        System.arraycopy(this.numberOfKeys, 0, result, offset,
                this.numberOfKeys.length);
        offset += this.numberOfKeys.length;

        for(KeyPointer kp : keyPointers) {
            offset += kp.getBytes(result, offset);
        }

        for(KeyData kd : keys) {
            offset += kd.getBytes(result, offset);
        }

        return result;
    }

    public static class KeyPointer implements StaticStruct, PrintableStruct {
        private final byte[] keyType = new byte[4];
        private final byte[] keyOffset = new byte[8];
        private final byte[] keyLength = new byte[8];

        public KeyPointer(ReadableRandomAccessStream stream) {
            int offset = 0;

            stream.readFully(keyType);
            if(getKeyType() != 1 && getKeyType() != 2) {
                warning("Previously unseen value at offset " + offset + ": " +
                        getKeyType());
            }
            offset += keyType.length;

            stream.readFully(keyOffset);
            offset += keyOffset.length;

            stream.readFully(keyLength);
            offset += keyLength.length;
        }

        public static int staticSize() {
            return 20;
        }

        public int size() {
            return staticSize();
        }

        /** Unknown variable with observed value 1/0x1. */
        public int getKeyType() { return Util.readIntBE(keyType); }

        /** Byte offset to the data of this key is located. */
        public long getKeyOffset() {
            return Util.readLongBE(keyOffset);
        }

        /** Length of this key's data. */
        public long getKeyLength() {
            return Util.readLongBE(keyLength);
        }

        public void print(PrintStream ps, String prefix) {
            ps.println(prefix + "V2Header.KeyPointer:");
            printFields(ps, prefix);
        }

        public void printFields(PrintStream ps, String prefix) {
            ps.println(prefix + " keyType: " + getKeyType());
            ps.println(prefix + " keyOffset: " + getKeyOffset());
            ps.println(prefix + " keyLength: " + getKeyLength());
        }

        public byte[] getBytes() {
            byte[] result = new byte[size()];
            getBytes(result, 0);
            return result;
        }

        public int getBytes(byte[] result, int offset) {
            final int startOffset = offset;

            System.arraycopy(this.keyType, 0, result, offset,
                    this.keyType.length);
            offset += this.keyType.length;

            System.arraycopy(this.keyOffset, 0, result, offset,
                    this.keyOffset.length);
            offset += this.keyOffset.length;

            System.arraycopy(this.keyLength, 0, result, offset,
                    this.keyLength.length);
            offset += this.keyLength.length;

            return offset - startOffset;
        }
    }

    public static interface KeyData extends DynamicStruct, PrintableStruct {
        public int getBytes(byte[] result, int offset);
    }

    public static class UserKeyData implements KeyData {
        private final byte[] kdfAlgorithm = new byte[4];
        private final byte[] kdfPrngAlgorithm = new byte[4];
        private final byte[] kdfIterationCount = new byte[4];
        private final byte[] kdfSaltLen = new byte[4];
        private final byte[] kdfSalt = new byte[32];
        private final byte[] blobEncIvSize = new byte[4];
        private final byte[] blobEncIv = new byte[32];
        private final byte[] blobEncKeyBits = new byte[4];
        private final byte[] blobEncAlgorithm = new byte[4];
        private final byte[] blobEncPadding = new byte[4];
        private final byte[] blobEncMode = new byte[4];
        private final byte[] encryptedKeyblobSize = new byte[4];
        private final byte[] encryptedKeyblob;
        private final byte[] reserved;

        public UserKeyData(ReadableRandomAccessStream stream, int length) {
            if(length < staticLength()) {
                throw new IllegalArgumentException("Not enough data for " +
                        "static user key data fields.");
            }

            int offset = 0;

            stream.readFully(kdfAlgorithm);
            if(getKdfAlgorithm() != 103) {
                warning("Previously unseen value for key derivation function " +
                        "algorithm: " + getKdfAlgorithm());
            }
            offset += kdfAlgorithm.length;

            stream.readFully(kdfPrngAlgorithm);
            if(getKdfPrngAlgorithm() != 0) {
                warning("Previously unseen value for prng algorithm: " +
                        getKdfPrngAlgorithm());
            }
            offset += kdfPrngAlgorithm.length;

            stream.readFully(kdfIterationCount);
            offset += kdfIterationCount.length;

            stream.readFully(kdfSaltLen);
            offset += kdfSaltLen.length;

            stream.readFully(kdfSalt);
            offset += kdfSalt.length;

            stream.readFully(blobEncIvSize, 0, blobEncIvSize.length);
            offset += blobEncIvSize.length;

            stream.readFully(blobEncIv);
            offset += blobEncIv.length;

            stream.readFully(blobEncKeyBits);
            offset += blobEncKeyBits.length;

            stream.readFully(blobEncAlgorithm);
            if(getBlobEncAlgorithm() != 17) {
                warning("Previously unseen value for key blob encryption " +
                        "algorithm: " +
                        getBlobEncAlgorithm());
            }
            offset += blobEncAlgorithm.length;

            stream.readFully(blobEncPadding);
            if(getBlobEncPadding() != 7) {
                warning("Previously unseen value for key blob encryption " +
                        "padding: " +
                        getBlobEncPadding());
            }
            offset += blobEncPadding.length;

            stream.readFully(blobEncMode);
            if(getBlobEncMode() != 6) {
                warning("Previously unseen value for key blob encryption " +
                        "mode: " +
                        getBlobEncMode());
            }
            offset += blobEncMode.length;

            stream.readFully(encryptedKeyblobSize);
            offset += encryptedKeyblobSize.length;

            encryptedKeyblob = new byte[getEncryptedKeyblobSize()];
            stream.readFully(encryptedKeyblob);
            offset += encryptedKeyblob.length;

            reserved = new byte[length - offset];
            stream.readFully(reserved);
        }

        public static int staticLength() {
            return 104;
        }

        public int length() {
            return staticLength() + encryptedKeyblob.length;
        }

        public int maxSize() {
            return Integer.MAX_VALUE;
        }

        public int occupiedSize() {
            return staticLength() + encryptedKeyblob.length;
        }

        /** Algorithm of the key derivation function. */
        public int getKdfAlgorithm() {
            return Util.readIntBE(kdfAlgorithm);
        }

        /** ? */
        public int getKdfPrngAlgorithm() {
            return Util.readIntBE(kdfPrngAlgorithm);
        }

        /** Iteration count (normally 1000). */
        public int getKdfIterationCount() {
            return Util.readIntBE(kdfIterationCount);
        }

        /** Length of kdfSalt (in bytes). */
        public int getKdfSaltLen() {
            return Util.readIntBE(kdfSaltLen);
        }

        /** Salt value for key derivation. */
        public byte[] getKdfSalt() {
            return Util.readByteArrayBE(kdfSalt);
        }

        /** Size of blobEncIv. */
        public int getBlobEncIvSize() {
            return Util.readIntBE(blobEncIvSize);
        }

        /** Initialization Vector for encryption-key unwrapping. */
        public byte[] getBlobEncIv() {
            return Util.readByteArrayBE(blobEncIv);
        }

        /** Number of bits in the keyblob's encryption key. */
        public int getBlobEncKeyBits() {
            return Util.readIntBE(blobEncKeyBits);
        }

        /** Encryption algorithm used to encrypt the key blob. */
        public int getBlobEncAlgorithm() {
            return Util.readIntBE(blobEncAlgorithm);
        }

        /** Padding. (?) */
        public int getBlobEncPadding() {
            return Util.readIntBE(blobEncPadding);
        }

        /** Encryption mode for the algorithm. */
        public int getBlobEncMode() {
            return Util.readIntBE(blobEncMode);
        }

        /** Size of encryptedKeyBlob. */
        public int getEncryptedKeyblobSize() {
            return Util.readIntBE(encryptedKeyblobSize);
        }

        /** The encrypted key blob, containing all keys. */
        public byte[] getEncryptedKeyblob() {
            return Util.readByteArrayBE(encryptedKeyblob);
        }

        public void print(PrintStream ps, String prefix) {
            ps.println(prefix + "V2Header.UserKeyData:");
            printFields(ps, prefix);
        }

        public void printFields(PrintStream ps, String prefix) {
            ps.println(prefix + " kdfAlgorithm: " + getKdfAlgorithm());
            ps.println(prefix + " kdfPrngAlgorithm: " + getKdfPrngAlgorithm());
            ps.println(prefix + " kdfIterationCount: " +
                    getKdfIterationCount());
            ps.println(prefix + " kdfSaltLen: " + getKdfSaltLen());
            ps.println(prefix + " kdfSalt: 0x" +
                    Util.byteArrayToHexString(getKdfSalt()));
            ps.println(prefix + " blobEncIvSize: " + getBlobEncIvSize());
            ps.println(prefix + " blobEncIv: 0x" +
                    Util.byteArrayToHexString(getBlobEncIv()));
            ps.println(prefix + " blobEncKeyBits: " + getBlobEncKeyBits());
            ps.println(prefix + " blobEncAlgorithm: " + getBlobEncAlgorithm());
            ps.println(prefix + " blobEncPadding: " + getBlobEncPadding());
            ps.println(prefix + " blobEncMode: " + getBlobEncMode());
            ps.println(prefix + " encryptedKeyblobSize: " +
                    getEncryptedKeyblobSize());
            ps.println(prefix + " encryptedKeyblob: 0x" +
                    Util.byteArrayToHexString(getEncryptedKeyblob()));
        }

        public byte[] getBytes() {
            byte[] result = new byte[occupiedSize()];
            getBytes(result, 0);
            return result;
        }

        public int getBytes(byte[] result, int offset) {
            final int startOffset = offset;

            System.arraycopy(this.kdfAlgorithm, 0, result, offset,
                    this.kdfAlgorithm.length);
            offset += this.kdfAlgorithm.length;

            System.arraycopy(this.kdfPrngAlgorithm, 0, result, offset,
                    this.kdfPrngAlgorithm.length);
            offset += this.kdfPrngAlgorithm.length;

            System.arraycopy(this.kdfIterationCount, 0, result, offset,
                    this.kdfIterationCount.length);
            offset += this.kdfIterationCount.length;

            System.arraycopy(this.kdfSaltLen, 0, result, offset,
                    this.kdfSaltLen.length);
            offset += this.kdfSaltLen.length;

            System.arraycopy(this.kdfSalt, 0, result, offset,
                    this.kdfSalt.length);
            offset += this.kdfSalt.length;

            System.arraycopy(this.blobEncIvSize, 0, result, offset,
                    this.blobEncIvSize.length);
            offset += this.blobEncIvSize.length;

            System.arraycopy(this.blobEncIv, 0, result, offset,
                    this.blobEncIv.length);
            offset += this.blobEncIv.length;

            System.arraycopy(this.blobEncKeyBits, 0, result, offset,
                    this.blobEncKeyBits.length);
            offset += this.blobEncKeyBits.length;

            System.arraycopy(this.blobEncAlgorithm, 0, result, offset,
                    this.blobEncAlgorithm.length);
            offset += this.blobEncAlgorithm.length;

            System.arraycopy(this.blobEncPadding, 0, result, offset,
                    this.blobEncPadding.length);
            offset += this.blobEncPadding.length;

            System.arraycopy(this.blobEncMode, 0, result, offset,
                    this.blobEncMode.length);
            offset += this.blobEncMode.length;

            System.arraycopy(this.encryptedKeyblobSize, 0, result, offset,
                    this.encryptedKeyblobSize.length);
            offset += this.encryptedKeyblobSize.length;

            System.arraycopy(this.encryptedKeyblob, 0, result, offset,
                    this.encryptedKeyblob.length);
            offset += this.encryptedKeyblob.length;

            return offset - startOffset;
        }
    }

    public static class UnknownKeyData implements KeyData {
        private final byte[] reserved;

        public UnknownKeyData(ReadableRandomAccessStream stream, int length) {
            reserved = new byte[length];
            stream.readFully(reserved);
        }

        public int occupiedSize() {
            return reserved.length;
        }

        public int maxSize() {
            return Integer.MAX_VALUE;
        }

        public byte[] getBytes() {
            byte[] result = new byte[reserved.length];
            getBytes(result, 0);
            return result;
        }

        public int getBytes(byte[] result, int offset) {
            System.arraycopy(reserved, 0, result, offset, reserved.length);
            return reserved.length;
        }

        public void print(PrintStream ps, String prefix) {
            ps.println(prefix + "V2Header.UnknownKeyData:");
            printFields(ps, prefix);
        }

        public void printFields(PrintStream ps, String prefix) {
            ps.println(prefix + " reserved: 0x" +
                    Util.byteArrayToHexString(reserved));
        }
    }

}
