/*-
 * Copyright (C) 2014 Erik Larsson
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.catacombae.dmg.sparseimage;

import java.io.PrintStream;
import org.catacombae.util.Util;

/** This class was generated by CStructToJavaClass. */
public class SparseImageHeader {
    /*
     * struct SparseImageHeader
     * size: 4096 bytes
     * description:
     *
     * BP  Size    Type        Identifier       Description
     * ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     * 0   1 * 4     u8[4]       signature        Must contain the string
     *                                            "sprs".
     * 4   4         be32        reservedAt4      Possibly the sparseimage
     *                                            format version (observed
     *                                            value: 3).
     * 8   4         be32        sectorsPerBlock  The number of sectors in each
     *                                            sparseimage block (observed
     *                                            value: 2048).
     * 12  4         be32        reservedAt12     Changes from 0x00000000 to
     *                                            0x00000001 when image goes
     *                                            from empty -> containing
     *                                            content. Stays at 0x00000001
     *                                            as new blocks are allocated.
     *                                            Likely to be a "flags" field
     *                                            of some kind.
     * 16  4         be32        sectorCount      The number of sectors in the
     *                                            virtual device.
     * 20  1 * 12    u8[12]      reservedAt20     Observed value: 0x0 for all
     *                                            bytes.
     * 32  4         be32        sectorCount2     The number of sectors in the
     *                                            virtual device (again). One of
     *                                            these two fields has some
     *                                            additional meaning.
     * 36  1 * 28    u8[28]      reservedAt36     Observed value: 0x0 for all
     *                                            bytes.
     * 64  4 * 1008  be32[1008]  blockMap         The block map, mapping real to
     *                                            virtual block indices.
     */

    public static final int STRUCTSIZE = 4096;

    private int signature;
    private int reservedAt4;
    private int sectorsPerBlock;
    private int reservedAt12;
    private int sectorCount;
    private final byte[] reservedAt20 = new byte[1 * 12];
    private int sectorCount2;
    private final byte[] reservedAt36 = new byte[1 * 28];
    private int[] blockMap;

    public SparseImageHeader(byte[] data, int offset) {
        this.signature = Util.readIntBE(data, offset+0);
        this.reservedAt4 = Util.readIntBE(data, offset+4);
        this.sectorsPerBlock = Util.readIntBE(data, offset+8);
        this.reservedAt12 = Util.readIntBE(data, offset+12);
        this.sectorCount = Util.readIntBE(data, offset+16);
        System.arraycopy(data, offset+20, this.reservedAt20, 0, 1 * 12);
        this.sectorCount2 = Util.readIntBE(data, offset+32);
        System.arraycopy(data, offset+36, this.reservedAt36, 0, 1 * 28);
        this.blockMap = Util.readIntArrayBE(data, offset+64, 1008);
    }

    public static int length() {
        return STRUCTSIZE;
    }

    /** Must contain the string "sprs". */
    public final byte[] getSignature() {
        return Util.toByteArrayBE(this.signature);
    }

    /** Possibly the sparseimage format version (observed value: 3). */
    public final long getReservedAt4() {
        return Util.unsign(getRawReservedAt4());
    }

    /**
     * The number of sectors in each sparseimage block (observed value: 2048).
     */
    public final long getSectorsPerBlock() {
        return Util.unsign(getRawSectorsPerBlock());
    }

    /**
     * Changes from 0x00000000 to 0x00000001 when image goes from empty ->
     * containing content. Stays at 0x00000001 as new blocks are allocated.
     * Likely to be a "flags" field of some kind.
     */
    public final long getReservedAt12() {
        return Util.unsign(getRawReservedAt12());
    }

    /** The number of sectors in the virtual device. */
    public final long getSectorCount() {
        return Util.unsign(getRawSectorCount());
    }

    /** Observed value: 0x0 for all bytes. */
    public final short[] getReservedAt20() {
        return Util.unsign(getRawReservedAt20());
    }

    /**
     * The number of sectors in the virtual device (again). One of these two
     * fields has some additional meaning.
     */
    public final long getSectorCount2() {
        return Util.unsign(getRawSectorCount2());
    }

    /** Observed value: 0x0 for all bytes. */
    public final short[] getReservedAt36() {
        return Util.unsign(getRawReservedAt36());
    }

    /** The block map, mapping real to virtual block indices. */
    public final long[] getBlockMap() {
        return Util.unsign(getRawBlockMap());
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawReservedAt4() {
        return this.reservedAt4;
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawSectorsPerBlock() {
        return this.sectorsPerBlock;
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawReservedAt12() {
        return this.reservedAt12;
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawSectorCount() {
        return this.sectorCount;
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final byte[] getRawReservedAt20() {
        return Util.readByteArrayBE(this.reservedAt20);
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawSectorCount2() {
        return this.sectorCount2;
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final byte[] getRawReservedAt36() {
        return Util.readByteArrayBE(this.reservedAt36);
    }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int[] getRawBlockMap() {
        return Util.createCopy(this.blockMap);
    }

    public void printFields(PrintStream ps, String prefix) {
        ps.println(prefix + " signature: \"" +
                Util.readString(getSignature(), "US-ASCII") + "\"");
        ps.println(prefix + " reservedAt4: " + getReservedAt4());
        ps.println(prefix + " sectorsPerBlock: " + getSectorsPerBlock());
        ps.println(prefix + " reservedAt12: " + getReservedAt12());
        ps.println(prefix + " sectorCount: " + getSectorCount());
        ps.println(prefix + " reservedAt20: ");
        {
            short[] _array = getReservedAt20();
            for(int _i = 0; _i < 12; ++_i) {
                ps.println(prefix + "  [" + _i + "]:");
                ps.println(prefix + "    " + _array[_i]);
            }
        }
        ps.println(prefix + " sectorCount2: " + getSectorCount2());
        ps.println(prefix + " reservedAt36: ");
        {
            short[] _array = getReservedAt36();
            for(int _i = 0; _i < 28; ++_i) {
                ps.println(prefix + "  [" + _i + "]:");
                ps.println(prefix + "    " + _array[_i]);
            }
        }
        ps.println(prefix + " blockMap: ");
        {
            long[] _array = getBlockMap();
            for(int _i = 0; _i < 1; ++_i) {
                ps.println(prefix + "  [" + _i + "]:");
                ps.println(prefix + "    " + _array[_i]);
            }
        }
    }

    public void print(PrintStream ps, String prefix) {
        ps.println(prefix + "SparseImageHeader:");
        printFields(ps, prefix);
    }

    public byte[] getBytes() {
        byte[] result = new byte[length()];
        getBytes(result, 0);
        return result;
    }

    public int getBytes(byte[] result, int offset) {
        final int startOffset = offset;

        Util.arrayPutBE(result, offset, this.signature);
        offset += 4;

        Util.arrayPutBE(result, offset, this.reservedAt4);
        offset += 4;

        Util.arrayPutBE(result, offset, this.sectorsPerBlock);
        offset += 4;

        Util.arrayPutBE(result, offset, this.reservedAt12);
        offset += 4;

        Util.arrayPutBE(result, offset, this.sectorCount);
        offset += 4;

        System.arraycopy(this.reservedAt20, 0, result, offset,
                this.reservedAt20.length);
        offset += this.reservedAt20.length;

        Util.arrayPutBE(result, offset, this.sectorCount2);
        offset += 4;

        System.arraycopy(this.reservedAt36, 0, result, offset,
                this.reservedAt36.length);
        offset += this.reservedAt36.length;

        Util.arrayPutBE(result, offset, this.blockMap);
        offset += 4;

        return offset - startOffset;
    }
}
